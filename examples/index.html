<html>
<head>
14K raw, 8.3K bytes js compress, 2.8k gzip
<script>
const parser = new DOMParser(),
	AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
	
async function hcx(strings,...args) {
	for(let i=0;i<args.length;i++) {
		args[i] = await args[i];
	}
	return hcxSync(strings,...args);
}

function hcxSync(strings,...args) {
	if(args.some((arg) => arg && typeof(arg)==="object" && arg instanceof Node)) {
		args = args.map((arg) => arg && typeof(arg)==="object" && arg instanceof Node ? arg : new Text(arg+""))
		return args.length>1 ? args : args[0]; // template processing returned DOM nodes
		//return args;
	} 
	const value = strings.reduce((accum,str,i) => i<args.length ? accum += str + (args[i]===undefined ? "" : args[i]) : accum += str,"").trim();
	if(value.startsWith("<") && value.endsWith(">")) {
		let node = parser.parseFromString(`<div>${value}</div>`,"text/xml"); // allows parsing of invalid hmtl sub-fragments like <tbody> without <table>
		const err = node.querySelector("parsererror");
		if(err) {
			console.warn(err.innerText,value);
			node = parser.parseFromString(`<body>${value}</body>`,"text/html").body;
		}
		node.normalize();
		if(err) { // returning parsed HTML
			return node.childNodes.length>1 ? [].slice.call(node.childNodes) : node.firstChild;
		}
		// XML nodes are not HTMLElements, so we need to create them as such
		const nodes = [].slice.call(node.childNodes).map((node) => XMLtoHTML(node));
		return nodes.length>1 ? nodes : nodes[0]
	}
	return new Text(value);
}

const XMLtoHTML = (node) => {
	if(node.nodeType===1) {
		const html = node.innerHTML,
			attributes = [].slice.call(node.attributes),
			el = document.createElement(node.tagName);
		attributes.forEach((attribute) => {
			el.setAttribute(attribute.name,attribute.value);
		});
		for(child of node.childNodes) {
			el.appendChild(XMLtoHTML(child))
		}
		return el;
	}
	if(node.nodeType===3) {
		return new Text(node.data);
	}
	return node.cloneNode(true);
}

const render = async (node,model,target) => {
	node = await node;
	model = model ? await model : model={};
	if(!node || typeof(node)!=="object" || !(node instanceof Node)) {
		throw new TypeError("hcx.render expects a DOM Node as the first argument")
	}
	if(target) {
		const html = node.innerHTML,
			body = parser.parseFromString(`<body>${html}</body>`,"text/html").body;
		body.normalize();
		let count  = 0;
		const max = target.childNodes.length;
		while(target.firstChild && body.firstChild) {
			count++;
			target.firstChild.replacementNode = body.firstChild;
			target.replaceChild(body.firstChild,target.firstChild)
		}
		while(count<max && target.lastChild) {
			count++;
			target.removeChild(target.lastChild);
		}
		while(body.firstChild) {
			target.appendChild(body.firstChild)
		}
		node = target;
	}
	if(node.tagName!=="SCRIPT") {
		node.normalize();
		document.renderingNode = node;
		if(node.attributes) {
			for(const attribute of node.attributes) {
				let name = attribute.name;
				if(name.startsWith("on")) {
					const parts = name.split(":"),
						eventname = parts.length===2 ? parts[1] : name.substring(2),
						value = attribute.value;
					if(value.includes("${") && value.includes("}")) {
						node.hcxListeners || (node.hcxListeners = new Set());
						if(!node.hcxListeners.has(value)) {
							node.hcxListeners.add(value);
							node.addEventListener(eventname,async (event) => {
								document.renderingNode = node;
								const newvalue = await Function("hcx","model","with(model) { return hcx`" + value + "` }")(hcx,await model);
								document.renderingNode = null;
								if(newvalue) {
									node.setAttribute(attribute.name,newvalue.wholeText);
									if(typeof(node[name])==="function") {
										node[name](event);
									}
								}
							});
						}
					}
				} else if((attribute.originalContent || attribute.value.includes("${"))) {
					attribute.originalContent || (attribute.originalContent = attribute.value);
					let value = await Function("hcx","model","with(model) { return hcx`" + attribute.originalContent + "` }")(hcx,await model);
					if(name.startsWith(":")) {
						name = name.substring(1);
						value = value.wholeText.trim();
						try {
							value = JSON.parse(value);
						} catch(e) {
							;
						}
						if(value) {
							node.setAttribute(name,"");
						} else {
							node.removeAttribute(name);
						}
					} else {
						attribute.value = value.wholeText.trim();
					}
				}
			}
		}
		if(node.childNodes && !(node instanceof Text)) {
			if(node.originalContent) {
				const value = await Function("hcx","model","with(model) { return hcx`" + node.originalContent + "` }")(hcx,await model);
				if(value) {
					value.originalContent = node.originalContent;
					value.expandsInstruction = node.expandsInstruction;
					node.parentElement.replaceChild(value,node);
					node.replacementNode = value;
				}
			} else {
				for(const child of node.childNodes) {
					await render(child,model);
				}
				document.renderingNode = node;
			}
		}
		if(node instanceof Text && (node.originalContent||node.wholeText.includes("${"))) {
			node.originalContent || (node.originalContent = node.wholeText);
			const value = await Function("hcx","model","with(model) { return hcx`" + node.originalContent + "` }")(hcx, await model);
			if(value) {
				value.originalContent = node.originalContent;
				value.expandsInstruction = node.expandsInstruction;
				if(value instanceof Text) {
					node.data = value.wholeText;
				} else {
					node.parentElement.replaceChild(value,node);
					node.replacementNode = value;
				}
			}
		}
		if((node.nodeType===7 || node.nodeType===8) && /[\s\?]?hcx\s.*/.test(node.textContent)) { // if <!--hcx then patch it in after resolution
			const end = node.nodeType===7 ? node.textContent.length-1 : (node.textContent.endsWith("?") ? node.textContent.length-1 : node.textContent.length),
				start = node.textContent.indexOf("hcx") + 4;
				text = node.textContent.substring(start,end).trim(),
				value = await Function("hcx","model","with(model) { return hcx`" + text + "` }")(hcx,await model);
			node.instructionId || (node.instructionId=Math.random())
			for(const child of [].slice.call(node.parentNode.childNodes)) {
				if(child.expandsInstruction===node.instructionId) {
					node.parentNode.removeChild(child)
				}
			}
			if(Array.isArray(value)) {
				value.forEach((item) => {
					item.expandsInstruction = node.instructionId;
					node.parentElement.insertBefore(item,node);
				})
			} else {
				value.expandsInstruction = node.instructionId;
				node.parentElement.insertBefore(value,node);
			}
		}
		document.renderingNode = null;
	}
	return node;
}

const compile = (el) => {
	if(el && typeof(el)==="object" && el instanceof HTMLElement) {
		const f = (el,model,target) => render(el,model,target);
		return f.bind(null,el)
	}
	throw new TypeError("argument to hcx.compile must be HTMLElement")
}

const addEventListenersAux = (el,listeners) => {
	Object.keys(listeners).forEach((key) => {
		const handler = listeners[key],
			type = typeof(handler);
		if(handler && type==="object") {
			if(key==="on") {
				Object.keys(handler).forEach((event) => {
					el.addEventListener(event,handler[event]);
				})
			} else {
				for(const child of el.querySelectorAll(key)) {
					Object.keys(handler).forEach((event) => {
						child.addEventListener(event,handler[event]);
					})
				}
			}
		}
	})
	return el;
}
const addEventListeners = (component,listeners={}) => {
	const type = typeof(component);
	if(type==="function") {
		return async (...args)  => {
			const el = await component(...args),
				type = typeof(el);
			if(el && typeof(el)==="object" && el instanceof HTMLElement) {
				return addEventListenersAux(el,listeners);
			}
			throw new TypeError("component function must return an HTMLElement for hcx.addEventListeners")
		}
	}
	if(component && type==="object" && component instanceof HTMLElement) {
		return addEventListenersAux(components,listeners);
	}
	throw new TypeError("First argument to hcx.addEventListeners must be a function or HTMLElement")
}

const DEPENDENTS = new Map();

const reactor = (data) => {
	if(!data || typeof(data)!=="object") {
		return data;
	}
	let dependents = DEPENDENTS.get(data);
	if(!dependents) {
		DEPENDENTS.set(data,dependents = new Map());
	}
	const proxy = new Proxy(data,{
		 get(target,property) {
			 let value = target[property];
			 if(typeof(property)!=="symbol") {
				 if(value && typeof(value)==="object") {
					 value = reactor(value);
				 }
				 if(document.renderingNode) {
					 let set = dependents.get(property);
					 if(!set) {
						 dependents.set(property,set = new Set())
					 }
					 set.add(document.renderingNode);
				 }
			 }
			 return value;
		 },
		 set(target,property,value) {
			 if(target[property]!==value) {
				 if(value===undefined) {
					 delete target[property];
				 } else {
					 target[property] = value;
				 }
				 const set = dependents.get(property);
				 if(set) {
					 for(let node of Array.from(set.values())) {
						 const _node = node.replacementNode || node;
						 if(!_node.isConnected) {
							 set.delete(node);
							 if(set.size===0) {
								 dependents.delete(property);
							 }
						 } else {
							 if(node.replacementNode) {
								 set.delete(node);
								 set.add(node.replacementNode);
							 }
							 if(_node.render) {
								 _node.render(proxy);
							 } else {
								 render(_node,proxy);
							 }
						 }
					 }
				 }
			 }
			 return true;
		 }
	 });
	 return proxy;
}

const bindAux = (el,model) => {
	if(model && typeof(model)==="object") {
		const inputs = el.querySelectorAll("input, select, textarea");
		for(const input of inputs) {
			const property = input.getAttribute("bind")||input.getAttribute("name")||input.getAttribute("id");
			if(property) {
				input.addEventListener("change",(event) => {
					let currentValue = model,
						_model = model,
						key;
					const keys = property.split(".");
					while(currentValue && typeof(currentValue)==="object" && keys.length>0) {
						_model = currentValue;
						key = keys.shift();
						currentValue = currentValue[key];
					}
					if(keys.length===0) {
						let value = event.target.value;
						try {
							value = JSON.parse(value);
						} catch(e) {
							;
						}
						if(currentValue!==value) {
							_model[key] = value;
						}
					}
				})
			}
		}
	}
	return el;
}

const bind = (component,modelOrmodelArgIndex=0) => {
	const type = typeof(component);
	if(type==="function") {
		return async (...args) => {
			for(let i=0;i<args.length;i++) {
				args[i] = await args[i];
			}
			const el = await component(...args);
			if(el && typeof(el)==="object" && el instanceof HTMLElement) {
				return bindAux(el,args[modelOrmodelArgIndex]);
			}
			throw new TypeError("component function must return an HTMLElement for bind")
		}
	}
	if(component && type==="object" && component instanceof HTMLElement) {
		return bindAux(component,modelOrmodelArgIndex)
	}
	throw new TypeError("First argument to hcx.bind must be a function or HTMLElement")
}

const customElement = (tagName,component,{observed=[],callbacks={},extend={},defaultModel={},modelArgIndex=0,bound,listeners,reactiveObserved}={}) => {
	const type=typeof(component),
		cls = extend.class || HTMLElement,
		cname = tagName.split("-").map((part) => part[0].toUpperCase()+part.substring(1)).join(""),
		getObservedAttributes = () => {
			return observed.slice(0);
		},
		_customElement = Function("getObservedAttributes",`return class ${cname} extends ${cls.name} { constructor(model,options) { super(); this.construct(model,options) }  static get observedAttributes() { return getObservedAttributes(); }}`)(getObservedAttributes);
	if(component && type==="object" && component instanceof HTMLElement) {
		const _component = component;
		component = () => _compoenent;
	}
	if(typeof(component)!=="function") {
		throw new TypeError("Second argument to hcx.customElement must be a function or HTMLElement")
	}
	_customElement.prototype.construct = function(model={},options={}) {
		const el = this;
		let _model = model;
		_component = component;
		component = (...args) => {
			let model = args[modelArgIndex];
			_model = model||_model;
			model = new Proxy(_model,{
				get(target,property) {
					let value = target[property];
					if(value==null) {
						value = el.getAttribute(property);
						if(value) {
							value = Function("hcx","model","with(model) { return hcx`" + value + "` }")(hcxSync,model).wholeText;
							try {
								value = JSON.parse(value);
							} catch(e) {
								;
							}
						}
					}
					if(value==null || value==="") {
						value = defaultModel[property];
					}
					return value;
				}
			});
			args[modelArgIndex] = model;
			if(!this.shadowRoot) {
				this.attachShadow({mode: 'open'});
			}
			return render(_component(...args),model,this.shadowRoot);
		}
		if(bound) {
			component = bind(component,modelArgIndex);
		}
		if(listeners) {
			component = addEventListeners(component,listeners);
		}
		Object.defineProperty(this,"render",{configurable:true,value:(...args)=>component(...args)});
	}
	_customElement.prototype.adoptedCallback = function() {
		if(callbacks.adopted) {
			callbacks.adopted.call(this);
		}
	};
	_customElement.prototype.attributeChangedCallback = function(name,oldValue,newValue) {
		if(callbacks.attributeChanged) {
			callbacks.attributeChanged.call(this,name,oldValue,newValue);
		}
		if(reactiveObserved===true) {
			this.render();
		}
	};
	_customElement.prototype.connectedCallback = function() {
		if(callbacks.connected) {
			callbacks.connected.call(this);
		}
		this.render();
	};
	_customElement.prototype.disconnectedCallback = function() {
		if(callbacks.disconnected) {
			callbacks.disconnected.call(this);
		}
	};
	_customElement.prototype.observedAttributes = getObservedAttributes;
	_customElement.define = function() { customElements.define(tagName,this,extend.tagName ? {extends:extend.tagName} : undefined) };
	return _customElement;
}


</script>
<script>

let Table = ({header="",headings=[],rows=[]}) => {
	const cols = Math.max(headings.length,rows.reduce((accum,row) => accum = Math.max(accum,row.length),0));
	rows = rows.map((row) => row.length<cols ? row.slice().concat(new Array(cols-row.length)) : row); // pad rows
	return hcx`
		<table>
		${header ? `<thead id="header"><tr><th colspan="${cols}">${header}</th></tr></thead>` : ''}
		${headings.length>0 ? `<thead><tr>${headings.reduce((accum,heading) => accum += `<th>${heading}</th>`,"")}</tr></thead>` : ''}
		${rows.length>0 ? `<tbody>${rows.reduce((accum,row) => accum += `<tr>${row.reduce((accum,value) => accum += `<td>${value==null ? '' : value}</td>`,"")}</tr>`,"")}</tbody>` : ''}
		</table>
	`
};


const TableElement = customElement("table-element",Table,{observed:["header"],reactiveObserved:true});
TableElement.define();

Table = addEventListeners(Table,{"#header":{ click(event) { alert("header clicked") }}});

Table = bind(Table);

const tableConfig = {header:"My Table",headings:["Name","Email"],rows:[["joe","joe@somewhere.com"],["mary","mary@somewhere.com"]]},
	model = reactor({Table,tableConfig,count:0});

setTimeout(() => model.tableConfig.header = "Your Table",500);

</script>

<template id="content">
	<?hcx processing instruction ${count} ?><br>
	<button onclick="${count++}">${count}</button>
	<button on:click="${count++}">${count}</button>
	<button onclick="alert('ok')">Click Me</button>
	<div :hidden="${count>0}">Should be hidden after first count</div>
	<div id="${count}" :hidden="${count===0}">Should be visible after first count</div>
	${Table(tableConfig)}
	<form>
		<input value="${tableConfig.header}" bind="tableConfig.header">
	</form>
	<table>
	<tr><td>fixed</td></tr>
	<!-- hcx ${(()=>`<tr><td>dynamic ${count}</td></tr><tr><td>second row</td></tr>`)()} -->
	</table>
</template>
</head>
<body>

<table-element id="testtable" header="test header"></table-element>
<div id="app"></div>
<script>
const body = compile(document.getElementById("content"));
bind(body)(model,document.getElementById("app"));

setTimeout(() => document.getElementById("testtable").setAttribute("header","new test header"),500);

</script>
</body>
</html>